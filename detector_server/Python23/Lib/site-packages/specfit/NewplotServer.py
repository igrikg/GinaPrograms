from TacoServer  import *
from Numeric import *
import EventHandler
import SpecGraph
import Specfit
import SpecFunctions
import string
from Tkinter import *
import imp,os
import BalloonWidget


DEBUG=0
global NPBase
global NPState
global NPStatus
global NPOn
global NPOff
global NPSetValue
global NPSetArray
global NPGetArray
global NPReadSigValues
global NPGetDevs
global NPSetDevs

NPBase          = 0
NPState        = NPBase + 1
NPStatus        = NPBase + 2
NPOn            = NPBase + 3
NPOff           = NPBase + 4
NPSetValue      = NPBase + 5
NPSetArray      = NPBase + 6
NPGetArray      = NPBase + 7
NPFitArray      = NPBase + 8
NPForceYmin     = NPBase + 9
NPDerive        = NPBase + 10
NPSmooth        = NPBase + 11
NPGetDict       = NPBase + 12
#NPReadSigValues   = NPBase + 8
#NPGetDevs       = NPBase + 9
#NPSetDevs       = NPBase + 10

class NewplotServer (TacoServer):
    "This is a Newplot TacoServer class"
    
#    Common variables for a class
    my_cmd_list = { NPState :    [D_VOID_TYPE, D_SHORT_TYPE , 'state','NPState'],
             NPStatus:        [D_VOID_TYPE, D_STRING_TYPE, 'status','NPStatus'],
             NPOn:        [D_VOID_TYPE, D_VOID_TYPE ,  'on','NPOn'],
             NPOff:        [D_VOID_TYPE, D_VOID_TYPE ,  'off','NPOff'],
             NPSetValue:    [D_FLOAT_TYPE, D_VOID_TYPE , 'set','NPSetValue'],
             NPSetArray:    [D_VAR_FLOATARR, D_VOID_TYPE , 'set_array','NPSetArray'],
             NPGetArray:    [D_VOID_TYPE, D_FLOAT_TYPE,  'read','NPGetArray'],
             #NPFitArray:    [D_VOID_TYPE, D_VAR_FLOATARR,'dofit','NPFitArray']}
             NPFitArray:    [D_VOID_TYPE, D_VAR_STRINGARR,'dofit','NPFitArray'],
             NPSmooth:        [D_VOID_TYPE, D_VOID_TYPE ,  'smooth','NPSmooth'],
             NPDerive:        [D_VOID_TYPE, D_VOID_TYPE ,  'derive','NPDerive'],
             NPForceYmin:[D_VOID_TYPE, D_VOID_TYPE ,  'forceymintozero','NPForceYmin'],
             NPGetDict:    [D_VAR_STRINGARR, D_VOID_TYPE ,'getdict','NPGetDict']}
             #NPGetDevs:    [D_VOID_TYPE, D_VAR_STRINGARR,'read_names'],
             #NPSetDevs:    [D_VAR_STRINGARR, D_VOID_TYPE,'register'] }
    class_name = "Newplot TacoServer Class"
        
    value      = 123.4
    names      = ('no', 'input')
    array       = (1,2,3)
    
    
    def __init__ (self, name,master=None,eh=None,graph=None,balloon=None):
        TacoServer.__init__ (self, name, command_list=self.my_cmd_list)
        #res = dev_getresource (self.dev_name, "value")
        res=456
        if master is None:
            print "opening Tk"
            self.master=Tk()
        else:
            self.master=master
        if eh is None:
            self.eh=EventHandler.EventHandler()
        else:
            self.eh=eh

        if balloon is None:
            self.balloon=BalloonWidget.BalloonWidget(self.master)
        else:
            self.balloon=balloon

        if graph is None:
            self.graph=SpecGraph.SpecGraph(self.master,eventhandler=self.eh)
            self.graph.  grid(row=3,column=1,sticky='nsew')
            xs    = ['Equis', array([1,2,3,4,5,6,7])]
            data  = ['Counts','Equis',array([1,2,3,4,3,2,1])]
            data2 = ['Square','Equis',array([1,4,9,16,9,4,1])]

        #Try to pass the data as events
            XNewDataEvent=self.eh.create('XNewDataEvent')
            self.eh.event(XNewDataEvent,data={'xname' : 'Equis',
                                 'xdata':xs[1]})
            YNewDataEvent=self.eh.create('YNewDataEvent')
            self.eh.event(YNewDataEvent,data={'xname' : 'Equis',
                    'yname' : 'Counts','ydata':data[2]})
            self.eh.event(YNewDataEvent,data={'yname':data2[0],'xname':data2[1],
                    'ydata':data2[2],'color':'red'})
            self.master.update()
        else:
            self.graph=graph
        if res != None:
            self.value = float(res);
        self.names=()
        self.spec={}
        self.mathfuns=None
        self.fitwin=None
        self.prnconf=None
        self.wtoolbar()
        return

    def wtoolbar(self):
         self.wt=Frame(self.master,relief='raise',bd=1)
         loc    = imp.find_module('WToolbar')[1]
         moddir = os.path.dirname(loc)
         if moddir == "":
             moddir = '.'

         tozerogif  = '%s/images/ymintozero.gif' % moddir
         swapgif    = '%s/images/swapsign.gif' % moddir
         smoothgif  = '%s/images/smooth.gif' % moddir
         derivegif  = '%s/images/derive.gif' % moddir
         fitgif     = '%s/images/fit.gif' % moddir
         zoomingif  = '%s/images/zoomin.gif' % moddir
         zoomoutgif = '%s/images/zoomout.gif' % moddir

         tozero  = self.wt.tk.call('image','create','photo','-file',tozerogif)
         swapsign  = self.wt.tk.call('image','create','photo','-file',swapgif)
         smooth  = self.wt.tk.call('image','create','photo','-file',smoothgif)
         derive  = self.wt.tk.call('image','create','photo','-file',derivegif)
         fit     = self.wt.tk.call('image','create','photo','-file',fitgif)

         tozero_b  = Button(self.wt,relief='flat',bd=2,image=tozero,
                          command=self.forceymintozero)
         swapsign_b  = Button(self.wt,relief='flat',bd=2,image=swapsign,
                          command=self.swapsign)
         smooth_b  = Button(self.wt,relief='flat',bd=2,image=smooth,
                          command=self.smooth)
         derive_b  = Button(self.wt,relief='flat',bd=2,image=derive,
                          command=self.derive)
         fit_b     = Button(self.wt,relief='flat',bd=2,image=fit,
                          command=self.fit)

         self.balloon.bind(tozero_b ,"Force ymin = 0",statusHelp=None)
         self.balloon.bind(swapsign_b ,"Multiply by -1",statusHelp=None)
         self.balloon.bind(smooth_b ,"Smooth",statusHelp=None)
         self.balloon.bind(derive_b ,"Derivate",statusHelp=None)
         self.balloon.bind(fit_b ,"Fit Window",statusHelp=None)

         tozero_b. bind('<Enter>',self.__relief,'+')
         swapsign_b. bind('<Enter>',self.__relief,'+')
         smooth_b. bind('<Enter>',self.__relief,'+')
         derive_b. bind('<Enter>',self.__relief,'+')
         fit_b.    bind('<Enter>',self.__relief,'+')
         
         tozero_b. bind('<Leave>',self.__unrelief,'+')
         swapsign_b. bind('<Leave>',self.__unrelief,'+')
         smooth_b. bind('<Leave>',self.__unrelief,'+')
         derive_b. bind('<Leave>',self.__unrelief,'+')
         fit_b.    bind('<Leave>',self.__unrelief,'+')

         tozero_b. grid(row=0,column=1,sticky='w')
         swapsign_b. grid(row=0,column=2,sticky='w')
         smooth_b. grid(row=0,column=3,sticky='w')
         derive_b. grid(row=0,column=4,sticky='w')
         fit_b.    grid(row=0,column=5,sticky='w')

         self.wt.columnconfigure(10,weight=1) 
         self.wt.grid(row=1,column=0,sticky='we',columnspan=2)


    def __relief(self,event):
         """
         Give relief to a button when mouse passes on it.
         """
         event.widget.configure(relief='raise')

    def __unrelief(self,event):
         """
         Unrelief a button when mouse leave it.
         """
         event.widget.configure(relief='flat')
        
    def state (self):
#        print 'remote device status:'
#        print self.rem_device.DevStatus()        
        return self.dev_state
        
    def status (self):
        if self.dev_state == DEVUNKNOWN:
            self.dev_status = "The device is in an unknown state"
        elif self.dev_state == DEVON:
            self.dev_status = "The device is switched ON"
        elif self.dev_state == DEVOFF:
            self.dev_status = "The device is switched OFF"        
        return self.dev_status
        
    def on (self):
        self.dev_state = DEVON
        
    def off (self):
        self.dev_state = DEVOFF
        
    def read (self):
        return self.value

    def set (self, x):
        print x
        
        if x > 100:
            Server.error.taco_error = DevErr_ValueOutOfBounds    
            raise Server.error
            
        elif x < 0:
            x / 0
                        
        self.value = x
        return 
        
    def read_signals (self):
        return self.array
        
    def read_names (self):
        output=()
        for key in self.specs:
            output=output+ (key,)
        return output

    def getdict(self,x):
        print x
        return
        
    def register (self, in_names):
            #
        # A copy to a new tuple is needed here!!!
        # self.names = in_names
        # will result in a memory fault when
        # executing read_names!
        #
        #self.names = ()
        for i in in_names:
            print i
            if self.specs.has_key(i):
               pass
            else:
               self.specs[i]=SpecClass.SpecClass()
        return

    def set_array (self, x):
        #
        # A copy to a new tuple is needed here!!!
        # self.array = x
        # will result in a memory fault when
        # executing read_signals!
        #    
        #self.array = ()
        #for i in x:
        #    self.array = self.array + (i, )
        self.array=array(map(string.atof,x))
        ResetLimitDataEvent=self.eh.create('ResetLimitDataEvent')
        self.eh.event(ResetLimitDataEvent)
        ResetLimitDataEvent=self.eh.create('ResetEvent')
        self.eh.event(ResetLimitDataEvent)
        xplot=self.array[0:len(self.array):2]
        yplot=self.array[1:len(self.array):2]
        #print xplot
        #print yplot
        XNewDataEvent=self.eh.create('XNewDataEvent')
        self.eh.event(XNewDataEvent,data={'xname':'X',
                                         'xdata':xplot})
        YNewDataEvent=self.eh.create('YNewDataEvent')
        self.eh.event(YNewDataEvent,data={'xname':'X',
                                         'yname':'Y',
                                         'ydata':yplot})
        return 

    def fit(self):
      """
      Extract data of the active graph, and create a Specfit object
      to make a fit of these data.
      """
      if self.fitwin and self.fitwin.winfo_exists() == 1:
            self.fitwin.lift()
            self.fitupdate()
            return

      #source = self.wsrc.getconf('source')
      #scan   = self.wsrc.getconf('scan')
      xdata  = self.graph.getactiveconf('xdata')
      ydata  = self.graph.getactiveconf('ydata')
      xmin, xmax = self.graph.getactiveconf('x_limits')
      yname  = self.graph.getactiveconf('yname')
      xname  = self.graph.getactiveconf('xname')
      moncounter = self.graph.getactiveconf('moncounter')
      if moncounter != 'none':
            mondata = self.graph.getactiveconf('mondata')
      else:
            mondata = []

      if ydata:
           self.fitwin = Specfit.Specfit(self.master,eh=self.eh,
                                       #source=source,
                                       xdata=xdata,
                                       ydata=ydata,
                                       xmin=xmin, xmax=xmax,
                                       moncounter = moncounter,
                                       mondata = mondata,
                                       #scan=scan,
                                       dataupdate=self.fitupdate,
                                       yname=yname,xname=xname,
                                       prnconf=self.prnconf)

    def fitupdate(self):
      #check if the fit window exists and it is open
      # in principle it should be done for each Specfit instance ... 
      # self.fitwin is the instance
      if self.fitwin and self.fitwin.winfo_exists() == 1:
        #source = self.wsrc.getconf('source')
        source='source'
        #scan   = self.wsrc.getconf('scan')
        xdata  = self.graph.getactiveconf('xdata')
        ydata  = self.graph.getactiveconf('ydata')
        moncounter = self.graph.getactiveconf('moncounter')
        if moncounter != 'none':
            mondata = self.graph.getactiveconf('mondata')
        else:
            mondata = []
        xmin, xmax = self.graph.getactiveconf('x_limits')
        yname  = self.graph.getactiveconf('yname')
        xname  = self.graph.getactiveconf('xname')
        if ydata:
           #self.fitwin = Specfit.Specfit(self.master,eh=self.eh,source=source,
           self.fitwin.pretreat(source=source,
                                       xdata=xdata,
                                       ydata=ydata,
                                       xmin=xmin, xmax=xmax,
                                       #scan=scan,
                                       mondata=mondata,
                                       moncounter=moncounter,
                                       yname=yname,xname=xname)
        
    def dofit(self):
        output=[]
        if self.fitwin and self.fitwin.winfo_exists() == 1:
            if DEBUG:
                print "self.fitwin exists"                
            self.fitupdate()
        else:
            self.fit()
        if self.fitwin and self.fitwin.winfo_exists() == 1:
               self.fitwin.estimate()
               self.fitwin.startfit()
               if self.fitwin.state.get() == "Ready":
                    for param in self.fitwin.final_theory:
                        output.append("%s" % param)
                        output.append("%s" % self.fitwin.param_win.parameters [param] ['fitresult'].get())
               else:
                    self.graph.update()
        return output

    def smooth(self):
      """
      Extract data of the active graph, and smooth them
      """
      #if self.smoothwin and self.smoothwin.winfo_exists() == 1:
      #      self.smoothwin.lift()
      #      return
      if self.mathfuns == None:
            self.mathfuns= SpecFunctions.SpecFunctions(self,eh=self.eh)

      #source = self.wsrc.getconf('source')
      #scan   = self.wsrc.getconf('scan')
      xdata  = self.graph.getactiveconf('xdata')
      ydata  = self.graph.getactiveconf('ydata')
      yname  = self.graph.getactiveconf('yname')
      xname  = self.graph.getactiveconf('xname')
      if ydata:
      #    self.smoothwin = SpecSmooth.SpecSmooth(self,eh=self.eh,source=source,
      #                                       scan=scan,ydata=ydata,yname=yname,
      #                                       xdata=xdata,xname=xname)
        try:
            self.mathfuns.smooth(xdata,ydata,
                                   event=1,
                                   yname=yname,xname=xname)
        except:
            pass
            #tkMessageBox.showerror('Error','Error smoothing data')

    def derive(self):
      """
      Extract data of the active graph, and create a SpecFunctions object
      to make the derivative of the data.
      """
      if self.mathfuns == None:
            self.mathfuns= SpecFunctions.SpecFunctions(self,eh=self.eh)

      #source = self.wsrc.getconf('source')
      #scan   = self.wsrc.getconf('scan')
      xdata  = self.graph.getactiveconf('xdata')
      ydata  = self.graph.getactiveconf('ydata')
      yname  = self.graph.getactiveconf('yname')
      xname  = self.graph.getactiveconf('xname')
      xmin, xmax = self.graph.getactiveconf('x_limits')
      if ydata:
        try:
            self.mathfuns.numderiv(xdata,ydata,
                                   event=1,
                                   xmin=xmin,
                                   xmax=xmax,
                                   yname=yname,xname=xname)
        except:
            pass
            #tkMessageBox.showerror('Error','Error calculating derivative')

    def forceymintozero(self):
      """
      Extract data of the active graph, and create a SpecFunctions object
      to force the data to be greater or equal to 0.
      """
      if self.mathfuns == None:
            self.mathfuns= SpecFunctions.SpecFunctions(self,eh=self.eh)

      #source = self.wsrc.getconf('source')
      #scan   = self.wsrc.getconf('scan')
      xdata  = self.graph.getactiveconf('xdata')
      ydata  = self.graph.getactiveconf('ydata')
      yname  = self.graph.getactiveconf('yname')
      xname  = self.graph.getactiveconf('xname')
      
      if ydata:
        try:
            self.mathfuns.forceymintozero(xdata,ydata,
                                   event=1,
                                   yname=yname,xname=xname)
        except:
            pass
            #tkMessageBox.showerror('Error','Cannot force ymin to zero')
            
    def swapsign(self):
      """
      Extract data of the active graph, and create a SpecFunctions object
      to change the sign of the data.
      """
      if self.mathfuns == None:
            self.mathfuns= SpecFunctions.SpecFunctions(self,eh=self.eh)

      #source = self.wsrc.getconf('source')
      #scan   = self.wsrc.getconf('scan')
      xdata  = self.graph.getactiveconf('xdata')
      ydata  = self.graph.getactiveconf('ydata')
      yname  = self.graph.getactiveconf('yname')
      xname  = self.graph.getactiveconf('xname')
      if ydata:
        try:
            self.mathfuns.swapsign(xdata,ydata,
                                   event=1,
                                   yname=yname,xname=xname)
        except:
            pass
            #tkMessageBox.showerror('Error','Error swapping signs')
   
