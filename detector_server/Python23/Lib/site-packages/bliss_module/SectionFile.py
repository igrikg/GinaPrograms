#!/usr/bin/env python
##########################################################################
# File:         SectionFile.py
# $Header: /segfs/bliss/source/python/utils/RCS/SectionFile.py,v 1.2 2002/12/08 14:08:52 ahoms Rel $
# Project:      Bliss Python modules
# Desc:         Handling configuration files divided in sections
# Author(s):    A. Homs (ahoms@esrf.fr)
#
# $Log: SectionFile.py,v $
# Revision 1.2  2002/12/08 14:08:52  ahoms
# Separated linedict and dict; dict can change in derived classes.
# Added isempty, addsection, renamesection and addsectionline.
# Added dictionary-like values() and items().
#
# Revision 1.1  2002/11/28 14:53:01  ahoms
# Improved handling of empty file.
# Added SectionFile.has_key().
#
# Revision 1.0  2002/11/26 10:14:52  ahoms
# Added except2str
#
# Revision 0.5  2002/01/23 12:00:00  ahoms
# Initial release
#
##########################################################################


import os, string, sys, re
from SimpleRecord import *
from except2str import *

class SectionFile:
	lend_str = '[\t ]*(#(?P<comment>.*))?$'
	sect_str = '[\t ]*\\[(?P<section>[0-9a-zA-Z_]+)\\]' + lend_str
	valid_str = '[\t ]*(?P<valid>[^#\n]+)' + lend_str
	
	def __init__(self, filename=None, endonerr=0, backupmode=0):
		self.backupmode = backupmode
		self.filename = None
     		self.rescanfile(filename=filename, endonerr=endonerr)

	def setfilename(self, filename):
		if filename != self.filename:
			self.changed = 1
			
		self.filename = filename
		
	def rescanfile(self, filename=None, endonerr=None):
		filename = filename or self.filename
		if endonerr is None:
			endonerr = self.endonerr

		self.filename = filename
		self.endonerr = endonerr

		if filename:
			self.readfile(filename=filename, endonerr=endonerr)
		else:
			self.fileimage = ['']
			self.changed = 0
			
		self.scanfile()

	def readfile(self, filename=None, endonerr=0):
		self.linedict = {}
		self.fileimage = None
		
		if filename is None:
			return
		
		try:
			op = 'opening'
			file = open(filename, 'r')

			op = 'reading'
			self.fileimage = file.readlines()
			
			op = 'closing'
			file.close()
		except IOError:
			if endonerr:
                                action = '%s file %s' % (op, filename)
				print get_except_str(None, action)
                                print 'Aborting!'
				sys.exit(1)
			else:
				excpt = sys.exc_info()
				raise excpt[0], excpt[1], excpt[2]

		self.changed = 0
		
	def scanfile(self, fileimage=None):
                if len(self.fileimage) == 0 and fileimage is not None:
                        self.fileimage = fileimage
		if fileimage is None:
			fileimage = self.fileimage
			
		section = ''
		self.linedict = {}
		self.linedict[section] = []
		self.linemap = {}
		self.linemap[section] = Record(section=1, body=[])

		# line numbers start from 1
		# linetable will map the modified fileimage
		self.linetable = [None] + range(len(fileimage))
						 
		comment   = re.compile(SectionFile.lend_str)
		sect_obj  = re.compile(SectionFile.sect_str)
		valid_obj = re.compile(SectionFile.valid_str)

     		for i in xrange(len(fileimage)):
			line = fileimage[i]
			linenr = i + 1
			
			m = comment.match(line)
			if m is not None:
				continue
			
			m = sect_obj.match(line)
			if m is not None:
				section = m.group('section')
				self.linedict[section] = []
				self.linemap[section] = Record(section=linenr,
                                                               body=[])
				continue

			m = valid_obj.match(line)
			if m is not None:
				str = m.group('valid')
			else:
				print 'SectionFile: Unrecognized syntax on ' \
                                      'line %d: %s' % (linenr, line)
				str = line

			self.linedict[section].append(str)
			self.linemap[section].body.append(linenr)

		self.dict = self.linedict

	def isempty(self):
		if self.fileimage is None:
			return 1
		return len(self.fileimage) == 0 or self.fileimage == ['']
			
	def getsection(self, section=''):
		return self.dict[section]

	def getline(self, linenr):
		if linenr not in xrange(len(self.linetable)) or \
		   self.linetable[linenr] is None:
			return None

      		return self.fileimage[self.linetable[linenr]]

	def setline(self, linenr, line):
		if linenr not in xrange(len(self.linetable)) or \
		   self.linetable[linenr] is None:
			raise IndexError, 'SectionFile(setline): ' \
			                  'invalid linenr: %d' % linenr

		if line[-1] != '\n':
			line = line + '\n'
			
      		self.fileimage[self.linetable[linenr]] = line
		self.changed = 1
		
	def sectionend(self, section):
		linenr = self.linemap[section]
		if len(linenr.body) == 0:
			lastline = linenr.section
			if lastline == len(self.linetable):
				return lastline
		else:
			lastline = linenr.body[-1]

		return lastline + 1

	def fileend(self):
		if self.isempty():
			return 1

		return len(self.fileimage) + 1
		
	# these functions will generate a mismatch between self.fileimage and
	# self.linedict and self.linemap. thus, functions such as getsection, 
	# __getitem__ cannot be called until a scanfile is done
	def insertline(self, linenr, line):
		if linenr == 0 or \
                   linenr not in xrange(len(self.linetable) + 1):
			raise IndexError, 'SectionFile(insertline): ' \
			                  'invalid linenr: %d' % linenr

		if self.isempty() and len(self.fileimage) > 0:
			del self.fileimage[0]
			
		if linenr == len(self.linetable):
			newlinenr = len(self.fileimage)
		else:
			newlinenr = self.linetable[linenr]
			if newlinenr is None:
				if linenr == 1:
					newlinenr = 0
				elif self.linetable[linenr - 1] is not None:
					newlinenr = self.linetable[linenr - \
                                                                   1] + 1
				elif linenr == len(self.linetable) - 1:
					newlinenr = len(self.fileimage)
				elif self.linetable[linenr + 1] is not None:
					newlinenr = self.linetable[linenr - \
                                                                   1] + 1
				else:
					print 'Warning: SectionFile' \
                                              '(insertline): could not find ' \
					      'a place to insert %d' % linenr
					return 0

			self.linetable.append(self.linetable[-1] + 1)
       			del self.linetable[linenr]

		if line[-1] != '\n':
			line = line + '\n'
			
		self.fileimage.insert(newlinenr, line)
		self.changed = 1

		return 1
			
	def delline(self, linenr):
		if self.getline(linenr) is None:
			raise IndexError, 'SectionFile(delline): ' \
			                  'invalid linenr: %d' % linenr

		del self.fileimage[self.linetable[linenr]]
		self.linetable.insert(linenr, None)
		del self.linetable[-1]
		self.changed = 1

	def addsection(self, section):
		if self.linedict.has_key(section):
			raise KeyError, 'Config file already has a section ' \
			      '%s' % section
    
		lastline = self.fileend()

		if not self.isempty():
			self.insertline(lastline, '\n') # some space
		self.insertline(lastline, '[%s]' % section)

		self.linedict[section] = []
		self.linemap[section] = Record(section=lastline, body=[])
		
	def renamesection(self, oldsection, newsection):
		linenr = self.linemap[oldsection].section
		self.setline(linenr, '[%s]' % newsection)
		
	def addsectionline(self, section, line):
		linenr = self.sectionend(section)
		self.insertline(linenr, line)
		
	def keys(self):
		return self.dict.keys()

	def values(self):
		return self.dict.values()
	
	def items(self):
		return self.dict.items()
	
	def has_key(self, key):
		return self.dict.has_key(key)

	def __getitem__(self, key):
		return self.getsection(key)

	def getcomment(self, linenr):
		line = self.getline(linenr)
		comment_obj = re.compile(SectionFile.lend_str)
		m = comment_obj.search(line)
		if m is None:
			return None

		return m.group('comment')

	def getnicecomment(self, comment, linenr=-1):
		if comment is None and linenr > 0:
			comment = self.getcomment(linenr)

		if comment:
			comment = '#%s' % comment
		else:
			comment = ''

		return comment

	# backup mode:
	# 0: no backup
	# 1: one backup file
	# 2: history (new file each time)
	def setbackupmode(self, backupmode):
		self.backupmode = backupmode
		
	def dobackup(self, backup=None):
		if backup is None:
			backup = self.backupmode

		fexists = os.path.exists
		if backup == 0 or not fexists(self.filename):
			return

		fname = self.filename + '.bak'
		if backup == 1:
			if fexists(fname):
				os.unlink(fname)
      		elif backup == 2:
			nr = 1
			while fexists(fname):
				fname = '%s.bak%d' % (self.filename, nr)
				nr = nr + 1

		os.rename(self.filename, fname)
		
	def haschanged(self):
		return self.changed
			
	def savefile(self, backup=None):
		if not self.changed:
			return
		
		self.dobackup(backup)

		f = open(self.filename, 'wt')
		f.writelines(self.fileimage)
		f.close()
		
		self.changed = 0

