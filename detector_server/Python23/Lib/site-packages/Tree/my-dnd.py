# tree widget drag'n'drop demo
#
# 15-OCT-01 Last update

import profile
import os
import Tree
from Tkinter import *
class Co_Obj:
    def __init__(self):
        self.node = None
        self.flag='disabled'
        
co = Co_Obj()

class FileNode(Tree.Node):
    def __init__(self, *args, **kw_args):
        # call superclass
        apply(Tree.Node.__init__, (self,)+args, kw_args)
        # bind right-click
        self.widget.tag_bind(self.symbol, '<3>', self.popup_menu)
        self.widget.tag_bind(self.label, '<3>', self.popup_menu)
        #store now full path
        self.path = apply(os.path.join, self.full_id())
    # pop up menu on right click
    def popup_menu(self, event):
        menu=Menu(self.widget, tearoff=0)
        menu.add_command(label='Copy', command=self.copy)
        menu.add_command(label='Paste', state=co.flag, command=self.paste)
        menu.add_command(label='delete', command=self.remove)

        menu.tk_popup(event.x_root, event.y_root)

    # do this
    def copy(self):
        print 'copy', self.full_id()
        co.node = self
        co.flag = 'normal'
    # do that
    def remove(self):
        print 'delete', self.full_id()
        main_move(self,None,'delete')

    # do the other thing
    def paste(self):
        print 'paste', self.full_id()
        main_move(co.node,self,'copy')


class Tester:
    def __init__(self, root, name):
        # create window
        self.top=Toplevel(root)
        self.top.title(name)
        self.top.columnconfigure(0, weight=1)
        self.top.rowconfigure(0, weight=1)
        
        # create the control
        self.tree=Tree.Tree(master=self.top,
                            root_id=name,
                            text_offset=20,
                            line_flag=1,
                            root_label=name,
                            node_class=FileNode,
                            get_contents_callback=getfiles,
                            drop_callback=dnd_update,
                            height=400,
                            width=300)
        self.tree.grid(column=0, row=0, sticky='nsew')
        self.tree.name=name

        # add scrollbars
        sb=Scrollbar(self.top)
        sb.grid(column=1, row=0, sticky='ns')
        self.tree.configure(yscrollcommand=sb.set)
        sb.configure(command=self.tree.yview)
        
        sb=Scrollbar(self.top, orient=HORIZONTAL)
        sb.grid(column=0, row=1, sticky='ew')
        self.tree.configure(xscrollcommand=sb.set)
        sb.configure(command=self.tree.xview)

        # expand root
        self.tree.root.expand()
        
def getfiles(node):
    op=os.path
    try:
        names = os.listdir(node.path)
    except os.error:
        return
    names.sort(lambda a, b: cmp(os.path.normcase(a), os.path.normcase(b)))
    for filename in names:
        full=op.join(node.path, filename)
        name=filename
        folder=0
        if op.isdir(full):
            # it's a directory
            folder=1
        elif not op.isfile(full):
            # but it's not a file
            name=name+' (special)'
        if op.islink(full):
            # it's a link
            name=name+' (link to '+os.readlink(full)+')'
        node.widget.add_node(name=name, id=filename, flag=folder)
    
# update on drag'n'drop
def dnd_update(source, target):
    main_move(source, target,type='drop')

def main_move(source, target, type='drop'):

    op=os.path
    if type=='delete':
        try:
            os.system('/bin/rm -rf '+source.path)
        except os.error:
            return
        source.delete()
        return
        
    if type=='copy':
        # cannot copy into file
        if not target.expandable() : return
        # want to do a copy of file
        if source.parent_node is target.parent_node:
            t_path = source.path+'_copy'
        else: t_path = target.path
        # now hard copy the file
        try:
            os.system('/bin/cp -rf '+source.path+' '+t_path)
        except os.error:
            return
        return
    
    if type=='drop':
        #cannot accept dropping file to itself !!
        if target is source: return
        
        print source.path, target.path

        #change logic according to type of target
        if  not target.expandable():
            t_path=target.parent_node.path
            mv = target.insert_after
        else:
            t_path=target.path
            mv = target.insert_children
        
        try:
            os.system('/bin/mv '+source.path+' '+t_path)
        except os.error:
            print 'cannot move ', source.path, ' to ', t_path
            return

        #now update the tree    
        mv(target.widget.add_list(name=source.get_label(),
            id=source.id,
            flag=source.expandable_flag,
            expanded_icon=source.expanded_icon,
            collapsed_icon=source.collapsed_icon))
        source.delete()
        del source
def main():
    root=Tk()
    root.title("Drag'n'drop")
    root.geometry("+1+1")
    Button(command=root.quit, text="Quit").pack()
    
    t1=Tester(root, 'dir1')
    t1.top.geometry("+1+60")
    t2=Tester(root, 'dir2')
    t2.top.geometry("+350+60")
    
    root.mainloop()

profile.run('main()', 'tree-profile')
#main()

