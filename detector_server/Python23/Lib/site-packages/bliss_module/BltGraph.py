import Pmw
import Tkinter as Tk
import Selector
import tkColorChooser
#from BltGraphProperties import *

# --- default element configuration ---
elt_counter	= 0
elt_symbols	= ['circle','square','diamond','plus','cross','splus','scross']
elt_colors	= ['#696','#9c0','#0c9','#690','#693','#060','#363', '#063','#093','#390']

def geteltconf(type):
    global elt_counter
    if type!='mca':
        symbol= elt_symbols[elt_counter % len(elt_symbols)]
    else:
	symbol= ''
    color= elt_colors[elt_counter % len(elt_colors)]
    elt_counter += 1
    return {'symbol': symbol, 'color': color, 'pixels': '0.1c'}

# --- defaults ROI configuration ---
roi_counter	= 0
roi_colors	= ['yellow', 'orange', 'red']
def getroiconf():
    global roi_counter
    colorno = roi_counter % len(roi_colors)
    roi_counter += 1
    return {'fill': roi_colors[colorno], 'linewidth':0, 'outline': roi_colors[colorno], 'stipple':'gray25'}

# --- defaults PEAK configuration ---
def getpeakconf():
    return {'outline':'black', 'linewidth':2, 'dashes':''}


class BltGraph(Pmw.Blt.Graph):
    def __init__(self, master, legend=1, type='mca'):
	self.master	= master

	Pmw.Blt.Graph.__init__(self, self.master, topmargin=0,title="", bufferelements=0)

	self.xvector	= {}
	self.elements	= {}
	self.active	= None
	
	self.rois	= {}
	self.roiactive	= None

	self.__xaxis	= ()
	self.__yaxis	= ()
	self.__xview	= ()
	self.__yview	= ()
	self.__zoom	= 0

	self.type	= type

	self.legend	= legend
	self.__create_legend()
	self.__create_pen()

	self.crosshairs	= GraphCrosshairs(self)
	self.gridlines	= GraphGridlines(self)
	self.axis	= {}
	self.axis['x']	= GraphAxis(self, 'x')

	self.element_popup = None

	self.__create_menu()
	self.__create_bind()

    def __create_bind(self):
	self.bind('<Button-1>', self.deactivate)
	#self.bind('<Double-Button-1>', self.popup_properties)
	#self.bind('<Button-1>', self.axis_start_scroll)
	#self.bind('<Shift-B1-Motion>', self.axis_scroll)
	#self.bind('<ButtonRelease-1>', self.axis_end_scroll)
	self.bind('<Button-3>', self.popup_menu)

    def __create_legend(self):
	if self.legend:
	    hide= 0
	else:
	    hide= 1
	self.legend_configure(anchor='sw',position='bottom',
                              relief='flat',
                              padx=4, hide=hide,
                              foreground='#000',background="#eec",
                              activerelief='raised',
                              activebackground="#eeeeee",
                              activeforeground="#f00")

    def __create_pen(self):
	self.activepen= 'activepen'
	self.activepenobj= self.pen_create('activepen',pixels='0.1c',
                                           symbol='', linewidth=1.5,
                                           color='#f00')

    # --- RESIZE ---
    def resize(self, width, height):
	self.configure(width=width, height=height)

    # --- AXIS SCROLL ---
    def axis_scroll(self, event):
	if not self.inside(event.x, event.y):
	    (x, y)= self.invtransform(event.x, event.y)
	    (xmin, xmax)= self.xaxis_limits()
	    (ymin, ymax)= self.yaxis_limits()
	    if x>xmin and x<xmax:
		print 'X SCROLLING'
	    elif y>ymin and y<ymax:
		print 'Y SCROLLING'
	    

    # --- GRAPH POPUP MENU ---
    def __create_menu(self):
	self.__menu = Tk.Menu(self,tearoff=0)
	self.__menu.add_command(label='Zoom +', command= self.zoomplus)
	self.__menu.add_command(label='Zoom -', command= self.zoomminus)
	self.__menu.add_command(label='Reset zoom', command= self.zoomreset)
	self.__menu.add_separator()
        self.__menu.add_command(label='Toggle gridlines',command=self.gridlines.toggle)
	self.__menu.add_command(label='Toggle crosshairs', command=self.crosshairs.toggle)
	#self.__menu.add_command(label='Properties', command=self.graph_properties)

    def popup_menu(self, event):
	if self.inside(event.x, event.y):
	    elt= self.element_closest(event.x, event.y, interpolate=1)
	    if elt is None:
		x= event.x + self.winfo_rootx()
		y= event.y + self.winfo_rooty()
		self.__menu.tk_popup(x, y)
	    else:
		self.elements[elt['name']].popupmenu(event)

    # --- PROPERTIES POPUP MENU ---
    def legend_properties(self, event):
	print 'legend_properties'

    def popup_properties(self, event):
	if self.inside(event.x, event.y):
	    elt= self.element_closest(event.x, event.y, interpolate=1)
	    if elt is None:
	        self.graph_properties()
	    else:
	        self.element_properties(elt['name'])
	else:
	    eltname= self.legend_get('@%d,%d'%(event.x,event.y))
	    if eltname=='':
	        self.axis_properties()
	    else:
		self.element_properties(eltname)

    def graph_properties(self):
	print 'graph_properties'

    def axis_properties(self):
	print 'axis_properties'

    def element_properties(self, name):
	print 'element_properties', name
	if self.element_popup is None or self.element_popup.destroyed:
	    self.element_popup= ElementProperties(self, self.elements, name)
	else:
	    self.element_popup.show(name)

    # --- LINE, POLYGON, ... in Tkinter canvas style ---
    def create_line(self, *args, **kw):
	""" Create a line in Tkinter canvas style:
		create_line(x0, y0, x1, y1, ..., xn, yn, options)
	    Coordinates should be given in view coord
	    Return a new line ID
	"""
	coords= ()
	for idx in range(0, len(args)-1, 2):
	    coords += self.invtransform(args[idx], args[idx+1])
	kw['coords']= coords
	return self.marker_create('line', **kw)

    def coords(self, name, *args):
	""" Update coordinates of any marker (line, polygon)
	    Coordinates should be given in view coord
	"""
	coords= ()
	for idx in range(0, len(args)-1, 2):
	    coords += self.invtransform(args[idx], args[idx+1])
	self.marker_configure(name, coords=coords)

    def create_rectangle(self, *args, **kw):
	""" Create a rectangle in Tkinter canvas style:
		create_polygon(x0, y0, x1, y1, options)
	    Coordinates should be given in view coord
	    Return a new polygon ID
	"""
	coords= ()
	coords+= self.invtransform(args[0], args[1])
	coords+= self.invtransform(args[0], args[3])
	coords+= self.invtransform(args[2], args[3])
	coords+= self.invtransform(args[2], args[1])
	kw['coords']= coords
	return self.marker_create('polygon', **kw)

    def coords_rectangle(self, name, *args):
	""" Update rectangle coordinates
		coords_rectangle(x0, y0, x1, y1)
	    Coordinates should be given in view coord
	"""
	coords= ()
        coords+= self.invtransform(args[0], args[1])
        coords+= self.invtransform(args[0], args[3])
        coords+= self.invtransform(args[2], args[3])
        coords+= self.invtransform(args[2], args[1])
	self.marker_configure(name, coords=coords)

    def EraseObject(self, *args):
	""" Delete any matching marker
	"""
	self.marker_delete(*args)

    # --- ZOOM ---
    def __init_zoom(self):
	self.__zoom= 1
	self.__xaxis= self.xaxis_limits()
	self.__yaxis= self.yaxis_limits()
	self.__xview= self.__xaxis
	self.__yview= self.__yaxis
	
    def zoom(self, xcoord, ycoord):
	if not self.__zoom:
	    self.__init_zoom()
	self.__xview= xcoord
	self.__yview= ycoord

    	self.xaxis_configure(min=xcoord[0], max=xcoord[1])
	self.yaxis_configure(min=ycoord[0], max=ycoord[1])

    def zoomminus(self):
	if not self.__zoom:
	    self.__init_zoom()
	xstep= (self.__xview[1]-self.__xview[0])/2
	ystep= (self.__yview[1]-self.__yview[0])/2
	xmin= self.__xview[0]-xstep
	xmax= self.__xview[1]+xstep
	ymin= self.__yview[0]-ystep
	ymax= self.__yview[1]+ystep
	if xmin < self.__xaxis[0]:	xmin= self.__xaxis[0]
	if xmax > self.__xaxis[1]:	xmax= self.__xaxis[1]
	if ymin < self.__yaxis[0]:	ymin= self.__yaxis[0]
	if ymax > self.__yaxis[1]:	ymax= self.__yaxis[1]
	self.zoom((xmin, xmax), (ymin, ymax))

    def zoomplus(self):
	if not self.__zoom:
	    self.__init_zoom()
	xstep= (self.__xview[1]-self.__xview[0])/4
	ystep= (self.__yview[1]-self.__yview[0])/4
	self.zoom((self.__xview[0]+xstep, self.__xview[1]-xstep),
		  (self.__yview[0]+ystep, self.__yview[1]-ystep))

    def zoomallowed(self):
	if self.__xview==self.__xaxis and self.__yview==self.__yaxis:
	    return 0
	else:
	    return 1
	

    def zoomreset(self, event=None):
	if not self.__zoom:
	    self.__init_zoom()
	if self.__xaxis != self.__xview or self.__yaxis != self.__yview:
	    self.xaxis_configure(min="", max="")
	    self.yaxis_configure(min="", max="")
	    self.__init_zoom()

    # --- DATA ---
    def setx(self, xname, xdata):
	if xname in self.xvector.keys():
	    self.xvector[xname].set(xdata)
	else:
	    self.xvector[xname]= Pmw.Blt.Vector(len(xdata))
	    self.xvector[xname].set(xdata)

    def sety(self, xname, yname, ydata):
	if xname not in self.xvector.keys():
	    return 0
	else:
	    if yname in self.elements.keys():
		self.elements[yname].sety(ydata)
	    else:
		self.elements[yname]= GraphElement(self, xname, self.xvector[xname], yname, ydata, self.type)
		if self.active is None and self.legend:
		    self.elements[yname].select()

    def dely(self, yname):
	try:
	    self.elements[yname].delete()
	    del self.elements[yname]
	except:
	    print 'dely : %s not found'%yname

    def delx(self, xname):
	try:
	    del self.xvector[xname]
	except:
	    print 'delx : %s not found'%xname

    def getxnames(self):
	return self.xvector.keys()

    def getynames(self):
	return self.elements.keys()

    	
    def deactivate(self, event=None):
	""" Without event, deactivate all graphs, ROIs.
	    With event, if current mouse coordinates is outside any graphs and ROIs,
	    deactivate all, otherwise do nothing
	"""
	if event is not None:
	    found= self.element_closest(event.x, event.y, interpolate=1)
	    if found is None:
	        (x, y)= self.invtransform(event.x, event.y)
	        for key in self.rois.keys():
		    if self.rois[key].inside(x):
		        found= key
		        break
	else:
	    found= None
	if found is None:
	    self.setroiactive()
	    self.setactive()

    # --- Active ELEMENT ---
    def setactive(self, yname=None):
	if yname is not None:
	    if self.elements.has_key(yname):
		self.elements[yname].select()
	else:
	    self._setactive(yname)

    def getactive(self):
	""" Return None or element(graph) name
	"""
	return self.active

    def _setactive(self, yname):
	if self.active is not None:
	    self.elements[self.active].unselect()
	self.active= yname

    # --- ROI ---
    def addroi(self, name, min, max, **kw):
	""" Add a ROI on the graph
	"""
	if self.rois.has_key(name):
	    self.rois[name].delete()
	    del self.rois[name]
	self.rois[name]= GraphRoi(self, name, min, max, **kw)

    def setroiactive(self, name=None):
	""" if name is None, deactivate all ROIs, otherwise, activate ROI name
	"""
	if name is not None:
	    if self.rois.has_key(name):
	        self.rois[name].select()
	else:
	    self._roiactive(name)

    def getroiactive(self):
	""" Return None or active ROI name
        """
	return self.roiactive

    def _roiactive(self, name):
	if self.roiactive is not None:
	    self.rois[self.roiactive].unselect()
	self.roiactive= name

    def delroi(self, name):
	""" Delete ROI from graph
	"""
	if self.rois.has_key(name):
	    self.rois[name].delete()
	    del self.rois[name]

# ----------------------------------------------------------
# 		GRAPH ROIS
# ----------------------------------------------------------
class GraphRoi:
    def __init__(self, graph, roiname, roimin, roimax, roiconf=None):
	self.graph	= graph
	self.name	= roiname
	self.tname	= '_t_%s'%roiname
	self.min	= roimin
	self.max	= roimax
	self.roiconf	= getroiconf()
	if roiconf is not None:
	    self.roiconf.update(roiconf)

	self.selected	= 0
	self.__create()

    def delete(self):
	if self.selected:
	    self.graph._roiactive(None)
	self.graph.marker_delete(self.name)

    def __create(self):
	kw= {'coords': (self.min, '-Inf', self.min, 'Inf', self.max, 'Inf', self.max, '-Inf'),
	     'under': 1, 'name': self.name}
	kw.update(self.roiconf)
	self.roi= self.graph.marker_create('polygon', **kw)
	self.graph.marker_bind(self.name, '<Button-1>', self.select)

    def select(self, event=None):
	if not self.selected:
	    self.graph.marker_configure(self.name, linewidth=1)
	    self.graph.marker_create('text', name=self.tname, text=self.name, xoffset=5, yoffset=5,
					 background='white', anchor= 'nw', coords= (self.min, 'Inf'))
	    self.graph.marker_before(self.name)
	    self.graph._roiactive(self.name)
	    self.selected= 1

    def unselect(self):
	if self.selected:
	    self.graph.marker_configure(self.name, linewidth=0)
	    self.graph.marker_delete(self.tname)
	    self.selected= 0

    def inside(self, x):
	return (x <= self.max and x >= self.min)


# ----------------------------------------------------------
# 		GRAPH PEAKS
# ----------------------------------------------------------
class GraphPeak:
    def __init__(self, graph, name, x, label=None, element=None, peakconf=None):
	self.graph	= graph
	self.name	= name
	self.tname	= '_t_%s'%name
	self.x		= x
	self.element	= element
	self.label	= label or name

	self.peakconf	= getpeakconf()
	if peakconf is not None:
	    self.peakconf.update(peakconf)

	self.__create()

    def __create(self):
	#if self.element is None:
	ymax= 'Inf'
	#else:
	#    xdata= self.graph.elements[self.element].xvector
	#    ydata= self.graph.elements[self.element].yvector
	#    for idx in range(len(xdata)):
	#	if self.x<=xdata[idx]:	break
	#    if self.x==xdata[idx]:
	#	ymax= ydata[idx]
	#    else:
	#	ymax= (ydata[idx]+ydata[idx-1])/2
	kw= { 'name': self.name, 'coords': (self.x, '-Inf', self.x, ymax) }
	kw.update(self.peakconf)
	self.graph.marker_create('line', **kw)
	#if self.element is not None:
	#    self.graph.marker_configure(self.name, element=self.element)
	self.graph.marker_create('text', name=self.tname, text=self.label, hide=1, 
				 background='white', rotate=90,
				 anchor='se', xoffset=-1, coords= (self.x, '-Inf'))
	self.graph.marker_bind(self.name, '<Enter>', self.cb_enter)
	self.graph.marker_bind(self.name, '<Leave>', self.cb_leave)
	#self.graph.marker_bind(self.name, '<Button-1>', self.select)

    def select(self, event):
	print 'select', self.name	

    def cb_enter(self, event):
	self.graph.marker_configure(self.tname, hide=0)
	self.graph.marker_before(self.tname)

    def cb_leave(self, event):
	self.graph.marker_configure(self.tname, hide=1)
	self.graph.marker_after(self.tname)

    def delete(self):
	self.marker_delete(self.name)
	self.marker_delete(self.tname)

# ----------------------------------------------------------
# 		GRAPH ELEMENTS
# ----------------------------------------------------------
class GraphElement:
    def __init__(self, graph, xname, xvector, yname, ydata, type, cnfdict=None):

	self.graph	= graph
	self.activepen	= graph.activepen

	self.xvector	= xvector
	self.yvector	= Pmw.Blt.Vector(len(ydata))
	self.yvector.set(ydata)

	self.xname	= xname
	self.yname	= yname

	self.selected	= 0

	self.__create_element()
	self.__create_menu()

	self.default	= geteltconf(type)
	newconf		= self.default
	newconf.update(cnfdict or {})
	self.setconfig(newconf)

    # --- create element ---
    def __create_element(self):
	self.element= self.graph.line_create(self.yname, xdata= self.xvector, ydata= self.yvector)
	self.graph.element_configure(self.yname, activepen= self.activepen)
	self.graph.element_bind(self.yname, '<Button-1>', self.select)
	self.graph.legend_bind(self.yname, '<ButtonPress-1>',self.select)
	self.graph.legend_bind(self.yname, '<ButtonPress-3>',self.popupmenu)

    # --- delete element ---
    def delete(self):
	self.graph.element_delete(self.yname)

    def __delete(self):
	if self.selected:
	    self.graph.active= None
	self.graph.dely(self.yname)

    # --- clone element
    def __clone(self):
	clname= '%s-2'%self.yname
	self.graph.sety(self.xname, clname, self.yvector.get())

    # --- properties dialog
    def __properties(self):
	self.graph.element_properties(self.yname)

    # --- popup menu on legend ---
    def __create_menu(self):
	self.__menu = Tk.Menu(self.graph,tearoff=0)
	self.__menu.add_command(label='Graph: %s'%self.yname)
	self.__menu.add_separator()
        self.__menu.add_command(label='Delete',command=self.__delete)
	self.__menu.add_command(label='Clone', command=self.__clone)
	self.__menu.add_command(label='Properties', command=self.__properties)

    def popupmenu(self, event):
	self.select()
	x= event.x + self.graph.winfo_rootx()
	y= event.y + self.graph.winfo_rooty()
	self.__menu.tk_popup(x, y)

    # --- configuration ---
    def __getitem__(self, key):
	return self.graph.element_cget(self.yname, key)

    def __setitem__(self, key, value):
	kw= { key: value }
	self.graph.element_configure(self.yname, **kw)

    def getconfig(self):
	cnf= {}
	for key in ['color', 'dashes', 'fill', 'hide', 'label', 'offdash', 
			'outlinewidth', 'pixels', 'smooth', 'symbol']:
	    cnf[key]= self.graph.element_cget(self.yname, key)
	return cnf

    def setconfig(self, cnfdict):
	self.graph.element_configure(self.yname, **cnfdict)
	
    # --- selection (toggle active state) ---
    def select(self, event=None):
	if not self.selected:
	    self.graph.element_activate(self.yname)
	    self.graph.legend_activate(self.yname)
	    self.graph._setactive(self.yname)
	    self.selected= 1

    def unselect(self, event=None):
	if self.selected:
	    self.graph.element_deactivate(self.yname)
	    self.graph.legend_deactivate(self.yname)
	    self.selected= 0

    # --- data operation ---
    def setx(self, xdata, xname=None):
	self.xvector.set(xdata)
	if xname is not None:
	    self.xname= xname

    def sety(self, ydata, yname=None):
	self.yvector.set(ydata)
	if yname is not None:
	    self.yname= yname

    def addx(self, xdata):
	self.xvector.append(xdata)

    def addy(self, ydata):
	self.yvector.append(ydata)


# ----------------------------------------------------------
# 			AXIS
# ----------------------------------------------------------
class GraphAxis:
    def __init__(self, graph, name, cnfdict=None):
	self.g= graph
	self.name= name

    def __getitem__(self, key):
	return self.g.axis_cget(self.name, key)

    def __setitem__(self, key, value):
	cnf= { key: value }
	return self.g.axis_configure(self.name, **cnf)

    def getconfig(self):
	cnf= {}
	for key in ['color']:
	    cnf[key]= self[key]
	return cnf

    def setconfig(self, cnfdict):
	self.g.axis_configure(self.name, **cnfdict)

# ----------------------------------------------------------
# 			CROSSHAIRS
# ----------------------------------------------------------
class GraphCrosshairs:
    def __init__(self, graph, cnfdict=None):
	self.g= graph
	self.g.bind('<Motion>', self.__followmouse, '+')

	self.default= {'hide':1, 'dashes':1, 'linewidth':1, 'color':'black'}

	startconf= self.default
	if cnfdict is not None:
	    startconf.update(cnfdict)
	self.setconfig(startconf)

    def __getitem__(self, key):
	return self.g.crosshairs_cget(self, key)

    def __setitem__(self, key, value):
	cnf= { key: value }
	return self.g.crosshairs_configure(**cnf)

    def getconfig(self):
	cnf= {}
	for key in ['hide', 'dashes', 'linewidth', 'color']:
	    cnf[key]= self.g.crosshairs_cget(key)
	return cnf

    def setconfig(self, cnfdict):
	self.g.crosshairs_configure(**cnfdict)

    def __followmouse(self, event):
	if self.g.crosshairs_cget('hide')=='0':
	    self.g.crosshairs_configure(position='@%d,%d'%(event.x, event.y))
	   
    def toggle(self):
	self.g.crosshairs_toggle()

# ----------------------------------------------------------
# 			GRID
# ----------------------------------------------------------
class GraphGridlines:
    def __init__(self, graph, cnfdict=None):
	self.g= graph

	self.default= {'hide':1, 'dashes':1, 'linewidth':1, 'mapx':'x', 'mapy':'y', 'minor':0}

	startconf= self.default
	if cnfdict is not None:
	    startconf.update(cnfdict)
	self.setconfig(startconf)

    def __getitem__(self, key):
	return self.g.grid_cget(key)

    def __setitem__(self, key, value):
	cnf= { key: value }
	return self.g.grid_configure(**cnf)

    def setconfig(self, cnfdict):
	self.g.grid_configure(**cnfdict)

    def getconfig(self):
	for key in ['hide', 'dashes', 'linewidth', 'mapx', 'mapy', 'minor']:
	    cnf[key]= self.g.grid_cget(key)
	return cnf

    def toggle(self):
	self.g.grid_toggle()



def test():
    x = range(10)
    y1= range(10)
    y2= range(0, 20, 2)
    y3= range(0, 30, 3)

    root= Tk.Tk()
    g = BltGraph(root, legend=1)
    g.setx('x', x)
    g.sety('x', 'y1', y1)
    g.sety('x', 'y2', y2)
    g.sety('x', 'y3', y3)
    g.pack(fill='both', expand='yes')

    g.crosshairs.toggle()
    g.gridlines.setconfig({'hide':1})

    ycnf= g.elements['y1'].getconfig()
    ycnf['dashes']= 5
    ycnf['symbol']= 'triangle'
    g.elements['y1'].setconfig(ycnf)

    #g.marker_create('text', text='Hello', coords=(5,5))
    g.addroi('roi1', 2, 4)
    g.addroi('roi2', 3, 5)
    g.addroi('roi3', 6, 8)
    g.setroiactive('roi3')

    #d = GraphDialog(root, 'test')    

    p1= GraphPeak(g, 'p1', 4.5)
    p2= GraphPeak(g, 'p2', 6.5, element='y2')
    Tk.Button(text='test', command=lambda graph=g: BltGraph.delroi(graph,'roi3')).pack()
    root.mainloop()


if __name__=='__main__':
    test()
