#!/usr/bin/env python

import os, string, types, re
from math import *
from UserDict import UserDict

elements= [
	[1, 'H', 'hydrogen'],
	[2, 'He', 'helium'],
	[3, 'Li', 'lithium'],
	[4, 'Be', 'beryllium'],
	[5, 'B', 'boron'],
	[6, 'C', 'carbon'],
	[7, 'N', 'nitrogen'],
	[8, 'O', 'oxygen'],
	[9, 'F', 'fluorine'],
	[10, 'Ne', 'neon'],
	[11, 'Na', 'sodium'],
	[12, 'Mg', 'magnesium'],
	[13, 'Al', 'aluminium'],
	[14, 'Si', 'silicon'],
	[15, 'P', 'phosphorus'],
	[16, 'S', 'sulphur'],
	[17, 'Cl', 'chlorine'],
	[18, 'Ar', 'argon'],
	[19, 'K', 'potassium'],
	[20, 'Ca', 'calcium'],
	[21, 'Sc', 'scandium'],
	[22, 'Ti', 'titanium'],
	[23, 'V', 'vanadium'],
	[24, 'Cr', 'chromium'],
	[25, 'Mn', 'manganese'],
	[26, 'Fe', 'iron'],
	[27, 'Co', 'cobalt'],
	[28, 'Ni', 'nickel'],
	[29, 'Cu', 'copper'],
	[30, 'Zn', 'zinc'],
	[31, 'Ga', 'gallium'],
	[32, 'Ge', 'germanium'],
	[33, 'As', 'arsenic'],
	[34, 'Se', 'selenium'],
	[35, 'Br', 'bromine'],
	[36, 'Kr', 'krypton'],
	[37, 'Rb', 'rubidium'],
	[38, 'Sr', 'strontium'],
	[39, 'Y', 'yttrium'],
	[40, 'Zr', 'zirconium'],
	[41, 'Nb', 'niobium'],
	[42, 'Mo', 'molybdenum'],
	[43, 'Tc', 'technetium'],
	[44, 'Ru', 'ruthenium'],
	[45, 'Rh', 'rhodium'],
	[46, 'Pd', 'palladium'],
	[47, 'Ag', 'silver'],
	[48, 'Cd', 'cadmium'],
	[49, 'In', 'indium'],
	[50, 'Sn', 'tin'],
	[51, 'Sb', 'antimony'],
	[52, 'Te', 'tellurium'],
	[53, 'I', 'iodine'],
	[54, 'Xe', 'xenon'],
	[55, 'Cs', 'caesium'],
	[56, 'Ba', 'barium'],
	[57, 'La', 'lanthanum'],
	[58, 'Ce', 'cerium'],
	[59, 'Pr', 'praseodymium'],
	[60, 'Nd', 'neodymium'],
	[61, 'Pm', 'promethium'],
	[62, 'Sm', 'samarium'],
	[63, 'Eu', 'europium'],
	[64, 'Gd', 'gadolinium'],
	[65, 'Tb', 'terbium'],
	[66, 'Dy', 'dysprosium'],
	[67, 'Ho', 'holmium'],
	[68, 'Er', 'erbium'],
	[69, 'Tm', 'thulium'],
	[70, 'Yb', 'ytterbium'],
	[71, 'Lu', 'lutetium'],
	[72, 'Hf', 'hafnium'],
	[73, 'Ta', 'tantalum'],
	[74, 'W', 'tungsten'],
	[75, 'Re', 'rhenium'],
	[76, 'Os', 'osmium'],
	[77, 'Ir', 'iridium'],
	[78, 'Pt', 'platinum'],
	[79, 'Au', 'gold'],
	[80, 'Hg', 'mercury'],
	[81, 'Tl', 'thallium'],
	[82, 'Pb', 'lead'],
	[83, 'Bi', 'bismuth'],
	[84, 'Po', 'polonium'],
	[85, 'At', 'astatine'],
	[86, 'Rn', 'radon'],
	[87, 'Fr', 'francium'],
	[88, 'Ra', 'radium'],
	[89, 'Ac', 'actinium'],
	[90, 'Th', 'thorium'],
	[91, 'Pa', 'proactinium'],
	[92, 'U', 'uranium'],
	[93, 'Np', 'neptunium'],
	[94, 'Pu', 'plutonium'],
	[95, 'Am', 'americium'],
	[96, 'Cm', 'curium'],
	[97, 'Bk', 'berkelium'],
	[98, 'Cf', 'californium'],
	[99, 'Es', 'einsteinium'],
	[100, 'Fm', 'fermium'],
	[101, 'Md', 'mendelevium'],
	[102, 'No', 'nobelium'],
	[103, 'Lr', 'lawrencium'],
	[104, 'Rf', 'rutherfordium'],
	[105, 'Db', 'dubnium'],
	[106, 'Sg', 'seaborgium'],
	[107, 'Bh', 'bohrium'],
	[108, 'Hs', 'hassium'],
	[109, 'Mt', 'meitnerium']
]
# --- atomic mass unit
AMU= 1.660538

# --- predefined lists
dtb_energy= ['k_edge', 'l1_edge', 'l2_edge', 'l3_edge', 'm_edge', 'ka_edge', 'kb_edge', 'la_edge', 'lb_edge']
dtb_fluo= ['k_fluo', 'l1_fluo', 'l2_fluo', 'l3_fluo']
dtb_jump= ['k_jump', 'l1_jump', 'l2_jump', 'l3_jump']
dtb_element= ['symbol', 'Z', 'name', 'density', 'atweight', 'conv_fac']

# --- utility functions
ElementList= [ elt[1] for elt in elements ]
ZList= [ elt[0] for elt in elements ]
def Element2Z(element):
    return ZList[ElementList.index(element)]
def Z2Element(Z):
    return ElementList[ZList.index(Z)]


class Xray(UserDict):

    def __init__(self, filename=None):
	UserDict.__init__(self)

	# --- dict init
	for elt in elements:
	    self.data[elt[1]]= OneXray({'symbol':elt[1], 'Z':elt[0], 'name':elt[2]})

	# --- index for Z items
	self.symbol= ['']
	for elt in elements:
	    self.symbol.append(elt[1])

	# --- database file
	dirmod= os.path.dirname(__file__)
	if len(dirmod)==0:
	    dirmod= '.'
	self.database= '%s/%s.dat'%(dirmod, __name__)
	self.readfile(self.database)

	# --- user file
	if filename:
	    self.readfile(filename)


    # --- Overrides UserDict methods to works with both Z and symbol as key
    def __getkey__(self, key):
	if type(key)==types.IntType:
	    return self.symbol[key]
	else:
	    return key

    def __getitem__(self, key):
	return self.data[self.__getkey__(key)]

    def __setitem__(self, key, item):
	self.data[self.__getkey__(key)]= item

    def __delitem__(self, key):
	del self.data[self.__getitem__(key)]

    def has_key(self, key):
	return self.data.has_key(self.__getkey__(key))

    def get(self, key, failobj=None):
	return self.data.get(self.__getkey__(key), failobj)

    def setdefault(self, key, failobj=None):
	key= self.__getkey__(key)
	if not self.data.has_key(key):
	    self.data[key] = failobj
	return self.data[key]

    # --- composite cross-section
    def xsection(self, composite, ephot):
	""" Compute cross-section for a single element or a composite one.
	    A composite is defined with a string as follow: 
		'C22H10N2O5' means 22 * C, 10 * H, 2 * N, 5 * O
	    A composite cross-section is computed by:
		zi = Z of each element
		ni = number of element zi
		ai = atomic weight of element zi

		xsection = SUM(xsection(zi)*ni*ai) / SUM(ai*ni)
	    Result in cm2/g
	"""
        elts= [ w for w in re.split('[0-9]', composite) if w<>'' ]
        nbs= [ int(w) for w in re.split('[a-zA-Z]', composite) if w<>'' ]
        if len(elts)==1 and len(nbs)==0:
	    return self.data[elts[0]].xsection(ephot, unit='c')
        elif (len(elts)==0 and len(nbs)==0) or (len(elts)<>len(nbs)):
	    return None
	else:
	    compxsec= { 'absorption': 0.0, 'incoherent': 0.0, 'coherent': 0.0,
			'photoelectric': 0.0, 'total': 0.0 }
	    xsections= [ self.data[elt].xsection(ephot) for elt in elts ]
	    factors= [ self.data[elt]['weight']*nb for (elt, nb) in zip(elts, nbs) ]
	    div= 0
	    for (xsec, fact, nb) in zip(xsections, factors, nbs):
		div+= fact
		for key in xsec.keys():
		    compxsec[key]+= xsec[key]*nb
	    for key in compxsec.keys():
		compxsec[key]= compxsec[key]/(div*AMU)
	    return compxsec

    def transmission(self, composite, ephot, density, thickness):
	""" Compute transmission of a single element or a composite one (cf xsection)
	    ephot in keV
	    density in g/cm3
	    thickness in mm
	"""
	xsec= self.xsection(composite, ephot)['total'] 
	xsec= xsec * density / 10
	if xsec>0:
	    return exp(-xsec*thickness)
	else:
	    return xsec
	
    # --- read database file
    def readfile(self, filename):
	try:
	    self.__read_database(filename)
	except:
	    print 'Xray: ERROR - cannot read file <%s>'%filename
	    
	    
    def __read_database(self, filename):
	dtb= open(filename)

	for line in dtb.readlines():
	    line= line.strip()
	    if line[0:1]!='#' and len(line)>0:
	        if line[0:2]=='@D':
		    kwds= [kw.strip() for kw in line[2:].split(',')]
		    curr='D'
		elif line[0:2]=='@L':
		    kwds= line[2:].strip()
		    curr='L'
		else:
		    line= line.split(',')
		    dict= {}
		    if curr=='D':
		        if len(line)==len(kwds)+1:
			    for (kw, val) in zip(kwds, line[1:]):
			        dict[kw]= float(val)
			    self.data[self.symbol[int(line[0])]].update(dict)
		    elif curr=='L':
			dict[kwds]= [float(val) for val in line[1:]]
			self.data[self.symbol[int(line[0])]].update(dict)


class OneXray(UserDict):
    def __init__(self, dict):
	UserDict.__init__(self, dict)

    # --- sub-dict defined by a list of keys
    def getlist(self, list):
	result= {}
	for key in list:
	    if self.data.has_key(key):
		result[key]= self.data[key]
	if len(result)==0:
	    return None
	else:
	    return result

    def __getitem__(self, key):
	if type(key)==types.ListType:
	    return self.getlist(key)
	else:
	    return self.data[key]

    # --- predefined list
    def energy(self):
	return self.getlist(dtb_energy)

    def fluo(self):
	return self.getlist(dtb_fluo)

    def fluorescence(self):
	return self.getlist(dtb_fluo)

    def jump(self):
	return self.getlist(dtb_jump)

    def element(self):
	return self.getlist(dtb_element)


    # --- cross-sections for a given energy
    def xsection(self, ephot, unit=None):
	data= self.data
	result= {}

	# error
	if ephot<=0.0:
	    return {'error': 'Photon Energy <= 0.0'}
	if not data.has_key('k_fit'):
	    return {'error': 'No data for element <%s>'%self.data['symbol']}

	# non fatal error
	if fabs(data['k_edge']-ephot)<=0.001 or \
	   fabs(data['l1_edge']-ephot)<=0.001 or \
	   fabs(data['l2_edge']-ephot)<=0.001 or \
	   fabs(data['l3_edge']-ephot)<=0.001 or \
	   fabs(data['m_edge']-ephot)<=0.001:
	    	result['warning']= 'photon energy is within 1 eV of edge. fit results may be inaccurate.'

	# photo-absorption barns/atom x-section
	if ephot >= data['k_edge']:
	    barn_photo= self.calcxsect(ephot,data['k_fit'])
	elif ephot >= data['l3_edge']:
	    barn_photo= self.calcxsect(ephot,data['l_fit'])
	    if ephot < data['l1_edge']:
	        if ephot >= data['l2_edge']:
		    barn_photo /= data['l1_jump']
	        elif ephot >= data['l3_edge']:
		    barn_photo /= (data['l1_jump']*data['l2_jump'])
	    if data['symbol']<30:
		result['warning']= 'use L-edge fits for the M edges for Z<30. results may be inaccurate.'
	elif ephot >= data['m_edge']:
	    barn_photo = self.calcxsect(ephot,data['m_fit'])
	else:
	    barn_photo = self.calcxsect(ephot,data['n_fit'])

	# coherent, incoherent x-sections, and total
	barn_coh= self.calcxsect(ephot,data['xsect_coh'])
	barn_ncoh= self.calcxsect(ephot,data['xsect_ncoh'])
	barn_tot= barn_photo + barn_coh + barn_ncoh
	barn_abs= barn_tot * data['density'] / data['conv_fac']

	# unit conversion if necessary
	if unit:
	    if string.upper(unit)=='C':
	        barn_photo /= data['conv_fac']
	        barn_coh /= data['conv_fac']
	        barn_ncoh /= data['conv_fac']
	        barn_tot /= data['conv_fac']

	# return dict
	result['photoelectric']= barn_photo
	result['coherent']= barn_coh
	result['incoherent']= barn_ncoh
	result['total']= barn_tot
	result['absorption']= barn_abs

	return result


    def calcxsect(self, ephot, coeff):
	if ephot!=1.0:
	    log_e= log(ephot)
	else:
	    log_e= ephot
	xsec= coeff[0] + coeff[1]*log_e + coeff[2]*pow(log_e, 2) + coeff[3]*pow(log_e, 3)
	return exp(xsec)
	

def test():
    global __file__
    global __name__
    __file__= 'Xray.py'
    __name__= 'Xray'
    a= Xray()
    print a[4]
    print a['Si']['density']
    print a['Si']['l2_edge']

if __name__=='__main__':
    test()
